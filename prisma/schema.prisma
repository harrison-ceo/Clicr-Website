// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
}

// -----------------------------------------------------------------------------
// 1. Data Model: Multi-tenant Hierarchy
// -----------------------------------------------------------------------------

model Business {
  id        String   @id @default(uuid())
  name      String
  timezone  String   @default("UTC")
  settings  String?  // JSON string for refresh interval, thresholds, reset rules
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  venues          Venue[]
  users           User[]
  countEvents     CountEvent[]
  idScanEvents    IDScanEvent[]
  reportExportJobs ReportExportJob[]
}

model Venue {
  id            String   @id @default(uuid())
  businessId    String
  name          String
  address       String?
  capacityLimit Int?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  business      Business @relation(fields: [businessId], references: [id], onDelete: Cascade)
  areas         Area[]
  countEvents   CountEvent[]
  idScanEvents  IDScanEvent[]
}

model Area {
  id            String   @id @default(uuid())
  venueId       String
  name          String
  capacityLimit Int?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  venue         Venue    @relation(fields: [venueId], references: [id], onDelete: Cascade)
  clicrs        Clicr[]
  countEvents   CountEvent[]
  idScanEvents  IDScanEvent[]
}

model Clicr {
  id           String   @id @default(uuid())
  areaId       String
  name         String
  flowMode     String   // "IN_ONLY", "OUT_ONLY", "BIDIRECTIONAL"
  currentCount Int      @default(0) // Cached value
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  area         Area     @relation(fields: [areaId], references: [id], onDelete: Cascade)
  countEvents  CountEvent[]
  // ID scans usually happen at an area level, but can be linked to a clicr
  idScanEvents IDScanEvent[]
}

// -----------------------------------------------------------------------------
// 2. Roles & Permissions (RBAC)
// -----------------------------------------------------------------------------

model User {
  id        String   @id @default(uuid())
  businessId String
  email     String   @unique
  name      String?
  role      String   // "OWNER", "MANAGER", "DOOR_STAFF", "VIEWER"
  // For simplicity in this schema, simplistic mapping.
  // In a real app, might need many-to-many relationship for specific area assignments.
  // We can store assignments in a JSON field or separate table if complex.
  assignments String? // JSON: { venueIds: [], areaIds: [], clicrIds: [] }
  password  String   // Hashed
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  business      Business @relation(fields: [businessId], references: [id], onDelete: Cascade)
  countEvents   CountEvent[]
  idScanEvents  IDScanEvent[]
  reportExportJobs ReportExportJob[]
}

// -----------------------------------------------------------------------------
// 3. Event Logs (Append-Only Truth)
// -----------------------------------------------------------------------------

model CountEvent {
  id              String   @id @default(uuid())
  businessId      String
  venueId         String
  areaId          String
  clicrId         String
  userId          String?
  
  delta           Int      // +1, -1, +10, etc.
  flowType        String   // "IN", "OUT"
  eventType       String   // "TAP_INCREMENT", "TAP_DECREMENT", "BULK_ADJUST", "RESET"
  
  timestampServer DateTime @default(now())
  timestampClient DateTime?
  idempotencyKey  String   @unique // To prevent double-counting offline syncs

  business        Business @relation(fields: [businessId], references: [id])
  venue           Venue    @relation(fields: [venueId], references: [id])
  area            Area     @relation(fields: [areaId], references: [id])
  clicr           Clicr    @relation(fields: [clicrId], references: [id])
  user            User?    @relation(fields: [userId], references: [id])
}

model IDScanEvent {
  id              String   @id @default(uuid())
  businessId      String
  venueId         String
  areaId          String
  clicrId         String?
  userId          String?

  scanResult      String   // "ACCEPTED", "DENIED"
  age             Int?
  ageBand         String?  // "18-20", "21-24", etc.
  gender          String?  // "M", "F", "X"
  zipCode         String?
  
  timestamp       DateTime @default(now())

  business        Business @relation(fields: [businessId], references: [id])
  venue           Venue    @relation(fields: [venueId], references: [id])
  area            Area     @relation(fields: [areaId], references: [id])
  clicr           Clicr?   @relation(fields: [clicrId], references: [id])
  user            User?    @relation(fields: [userId], references: [id])
}

// -----------------------------------------------------------------------------
// 4. Reporting
// -----------------------------------------------------------------------------

model ReportExportJob {
  id          String   @id @default(uuid())
  businessId  String
  userId      String
  
  reportType  String   // "OCCUPANCY", "AUDIENCE", "FULL_DUMP"
  filters     String?  // JSON: { dateRange: ..., venueId: ... }
  format      String   // "XLSX", "CSV", "PDF"
  status      String   // "QUEUED", "PROCESSING", "COMPLETED", "FAILED"
  downloadUrl String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  business    Business @relation(fields: [businessId], references: [id])
  user        User     @relation(fields: [userId], references: [id])
}
